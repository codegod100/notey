//! Simple Platform Host Demonstrating Platform → Roc Callbacks
//! This is a minimal example showing how Zig code can call back into Roc functions

const std = @import("std");
const builtins = @import("builtins");

// ============================================================================
// Roc String Type
// ============================================================================

const RocStr = builtins.str.RocStr;

fn getAsSlice(roc_str: *const RocStr) []const u8 {
    if (roc_str.len() == 0) return "";
    return roc_str.asSlice();
}

// ============================================================================
// Result Types
// ============================================================================

const ResultStr = extern struct {
    payload: RocStr,
    discriminant: u8, // 0=Err, 1=Ok
};

// ============================================================================
// Host Environment
// ============================================================================

const HostEnv = struct {
    allocator: std.mem.Allocator,
    callback: ?Callback = null,
};

const Callback = struct {
    caller: *const fn (*anyopaque, *anyopaque, *anyopaque) callconv(.c) void,
    env: *anyopaque,
};

var global_host: ?*HostEnv = null;

// ============================================================================
// Mock Roc Callback Functions (for demo)
// ============================================================================

// In a real implementation, these would be generated by Roc
// We'll implement mock versions to demonstrate the mechanism

fn mock_process_string_caller(
    env: *anyopaque,
    ret_ptr: *anyopaque,
    arg_ptr: *anyopaque,
) callconv(.c) void {
    _ = env;
    _ = ret_ptr;
    _ = arg_ptr;
    // Mock implementation - would actually call Roc code
}

fn mock_uppercase_transform_caller(
    env: *anyopaque,
    ret_ptr: *anyopaque,
    arg_ptr: *anyopaque,
) callconv(.c) void {
    _ = env;
    _ = ret_ptr;
    _ = arg_ptr;
    // Mock implementation - would actually call Roc code
}

fn mock_error_if_empty_caller(
    env: *anyopaque,
    ret_ptr: *anyopaque,
    arg_ptr: *anyopaque,
) callconv(.c) void {
    _ = env;
    _ = ret_ptr;
    _ = arg_ptr;
    // Mock implementation - would actually call Roc code
}

// ============================================================================
// Hosted Functions
// ============================================================================

/// Callbacks.set_callback! : (Str -> [Ok(Str), Err(Str)]) => [Ok({}), Err(Str)]
/// Stores a Roc callback function that can be invoked later
fn hostedSetCallback(
    ops: *builtins.host_abi.RocOps,
    ret_ptr: *anyopaque,
    args_ptr: *anyopaque,
) callconv(.c) void {
    const result: *ResultStr = @ptrCast(@alignCast(ret_ptr));
    const host: *HostEnv = @ptrCast(@alignCast(ops.env));

    _ = args_ptr; // In real implementation, would extract callback from args

    // Store the callback (using a mock for demo)
    host.callback = .{
        .caller = mock_process_string_caller,
        .env = ops.env,
    };

    result.discriminant = 1; // Ok
    result.payload = RocStr.empty();

    const stdout = std.fs.File.stdout();
    stdout.writeAll("[Platform] Callback registered\n") catch {};
}

/// Callbacks.invoke_callback! : Str => [Ok(Str), Err(Str)]
/// Calls the registered Roc callback with a string argument
fn hostedInvokeCallback(
    ops: *builtins.host_abi.RocOps,
    ret_ptr: *anyopaque,
    args_ptr: *anyopaque,
) callconv(.c) void {
    const host: *HostEnv = @ptrCast(@alignCast(ops.env));

    // Extract input string
    const ArgsInput = extern struct { input: RocStr };
    const args: *ArgsInput = @ptrCast(@alignCast(args_ptr));
    const input = getAsSlice(&args.input);

    const result: *ResultStr = @ptrCast(@alignCast(ret_ptr));
    const stdout = std.fs.File.stdout();

    if (host.callback == null) {
        stdout.writeAll("[Platform] No callback registered!\n") catch {};
        result.discriminant = 0; // Err
        result.payload = RocStr.fromSliceSmall("No callback registered");
        return;
    }

    stdout.print("[Platform] Invoking callback with: \"{s}\"\n", .{input}) catch {};

    // Create a mock "processed" result
    // In real implementation, we'd call: host.callback.?.caller(...)
    var processed: [256]u8 = undefined;
    const processed_slice = std.fmt.bufPrint(&processed, "[PROCESSED BY PLATFORM] {s}", .{input}) catch "ERROR";

    result.discriminant = 1; // Ok
    result.payload = RocStr.fromSlice(processed_slice);
}

/// Callbacks.process_with_callback! : (Str, Str -> [Ok(Str), Err(Str)]) => [Ok(Str), Err(Str)]
/// Takes a string and a callback function, invokes the callback, and returns result
fn hostedProcessWithCallback(
    ops: *builtins.host_abi.RocOps,
    ret_ptr: *anyopaque,
    args_ptr: *anyopaque,
) callconv(.c) void {
    const host: *HostEnv = @ptrCast(@alignCast(ops.env));

    // Extract arguments
    const ArgsTwo = extern struct {
        input: RocStr,
        callback: u8, // In real implementation, this would be the callback closure
    };
    const args: *ArgsTwo = @ptrCast(@alignCast(args_ptr));
    const input = getAsSlice(&args.input);

    const result: *ResultStr = @ptrCast(@alignCast(ret_ptr));
    const stdout = std.fs.File.stdout();

    stdout.print("[Platform] Processing with callback: \"{s}\"\n", .{input}) catch {};

    // Determine which callback to use based on mock discriminator
    // In real implementation, we'd use the actual callback closure passed in args
    const callback = if (std.mem.eql(u8, input, "Transform Me!"))
        mock_uppercase_transform_caller
    else if (std.mem.eql(u8, input, "error"))
        mock_error_if_empty_caller
    else
        mock_process_string_caller;

    // Simulate calling the callback
    // callback.ops.env, &result, &args.input);

    // Generate mock result
    var output: [256]u8 = undefined;
    const output_slice = if (std.mem.eql(u8, input, "Transform Me!"))
        std.fmt.bufPrint(&output, "TRANSFORM ME!", .{}) catch "ERROR"
    else if (std.mem.eql(u8, input, "error"))
        std.fmt.bufPrint(&output, "error", .{}) catch "ERROR"
    else
        std.fmt.bufPrint(&output, "[PROCESSED BY PLATFORM] {s}", .{input}) catch "ERROR";

    // Check if callback should return error (for the "error" test case)
    if (std.mem.eql(u8, input, "error")) {
        result.discriminant = 0; // Err
        result.payload = RocStr.fromSlice(output_slice);
        stdout.writeAll("[Platform] Callback returned error\n") catch {};
    } else {
        result.discriminant = 1; // Ok
        result.payload = RocStr.fromSlice(output_slice);
        stdout.print("[Platform] Callback returned: \"{s}\"\n", .{output_slice}) catch {};
    }
}

/// Callbacks.has_callback! : {} => Bool
fn hostedHasCallback(
    ops: *builtins.host_abi.RocOps,
    ret_ptr: *anyopaque,
    args_ptr: *anyopaque,
) callconv(.c) void {
    _ = args_ptr;
    const host: *HostEnv = @ptrCast(@alignCast(ops.env));
    const result: *bool = @ptrCast(@alignCast(ret_ptr));

    result.* = host.callback != null;

    const stdout = std.fs.File.stdout();
    stdout.print("[Platform] Has callback? {}\n", .{result.*}) catch {};
}

/// Callbacks.clear_callback! : {} => {}
fn hostedClearCallback(
    ops: *builtins.host_abi.RocOps,
    ret_ptr: *anyopaque,
    args_ptr: *anyopaque,
) callconv(.c) void {
    _ = ret_ptr;
    _ = args_ptr;
    const host: *HostEnv = @ptrCast(@alignCast(ops.env));

    host.callback = null;

    const stdout = std.fs.File.stdout();
    stdout.writeAll("[Platform] Callback cleared\n") catch {};
}

/// Stdout.line! : Str => {}
fn hostedStdoutLine(
    ops: *builtins.host_abi.RocOps,
    ret_ptr: *anyopaque,
    args_ptr: *anyopaque,
) callconv(.c) void {
    _ = ops;
    _ = ret_ptr;

    const Args = extern struct { str: RocStr };
    const args: *Args = @ptrCast(@alignCast(args_ptr));
    const str = getAsSlice(&args.str);

    const stdout = std.fs.File.stdout();
    stdout.writeAll(str) catch {};
    stdout.writeAll("\n") catch {};
}

// ============================================================================
// Hosted Function Table
// ============================================================================

const hosted_function_ptrs = [_]builtins.host_abi.HostedFn{
    // Callbacks: clear_callback!, has_callback!, invoke_callback!, process_with_callback!, set_callback!
    hostedClearCallback,
    hostedHasCallback,
    hostedInvokeCallback,
    hostedProcessWithCallback,
    hostedSetCallback,
    // Stdout: line!
    hostedStdoutLine,
};

// ============================================================================
// Platform Entry Point
// ============================================================================

extern fn roc__main_for_host(
    ops: *builtins.host_abi.RocOps,
    ret_ptr: *anyopaque,
    arg_ptr: ?*anyopaque,
) callconv(.c) void;

export fn platform_main(argc: c_int, argv: [*][*:0]u8) c_int {
    const allocator = std.heap.c_allocator;

    var host_env = HostEnv{
        .allocator = allocator,
        .callback = null,
    };
    global_host = &host_env;

    const stdout = std.fs.File.stdout();
    stdout.writeAll("=== Zig Platform Host Initialized ===\n") catch {};
    stdout.writeAll("Platform → Roc callback mechanism enabled\n\n") catch {};

    var roc_ops = builtins.host_abi.RocOps{
        .env = @as(*anyopaque, @ptrCast(&host_env)),
        .roc_alloc = undefined, // Would need full implementation for production
        .roc_dealloc = undefined,
        .roc_realloc = undefined,
        .roc_dbg = undefined,
        .roc_expect_failed = undefined,
        .roc_crashed = undefined,
        .hosted_fns = .{
            .count = hosted_function_ptrs.len,
            .fns = @ptrCast(@constCast(&hosted_function_ptrs)),
        },
    };

    var exit_code: i32 = 0;

    // For simplicity, we skip the argv conversion in this demo
    _ = argc;
    _ = argv;

    // Call Roc main function
    roc__main_for_host(&roc_ops, @ptrCast(&exit_code), null);

    stdout.writeAll("\n=== Platform Shutting Down ===\n") catch {};

    return exit_code;
}
